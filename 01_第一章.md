## 2021/5/3 开始学习 Vue

### Object.defineProperty

- 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。

- 它们共享以下可选键值：

**value**

> 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。

**configurable**

> 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。

**enumerable**

> 当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。

**writable**

> 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。

- 存取描述符可以具有以下可选键值：

**get**

> 属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的 this 并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。
> 默认为 undefined。

**set**

> 属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。
> 默认为 undefined。

### 响应式数据变化

- vue 的特点：
- 如果是对象，就会使用 Object.defineProperty
- 会把数组的方法重写
- 如果给对象新增属性，是不会被监控的，因为不会触发 set 方法
- vue 提供了$set 方法增加属性 vm.$set( target, propertyName/index, value )

### 使用 proxy 实现响应式的原理

- vue3.0 如果浏览器支持就使用 proxy，不支持就使用 defineProperty

```js
function render() {
  console.log("模拟视图的更新");
}

const obj = {
  name: "zs",
  age: {
    age: 100,
  },
  arr: [],
};

const handler = {
  get(target, key) {
    // 可能target[key]也是一个对象,再对这个对象进行劫持
    if (typeof target[key] === "object" && target[key] !== null) {
      return new Proxy(target[key], handler);
    }
    return Reflect.get(target, key);
  },
  set(target, key, value) {
    // 对数组进行修改时会触发两次set，一次是修改值，一次是修改length
    if (key === "length") return true;
    render();
    return Reflect.set(target, key, value);
  },
};

const proxy = new Proxy(obj, handler);

proxy.age.age = 100; // 会先触发一次get，再触发一次set

// console.log(proxy);

proxy.arr.push(200);
```

### mustache 语法

- {{}}内可以写运算、取值、输出、三元，不能写 js 语法

```html
<div id="app">
  {{msg}} {{1+1}} {{info.a}} {{ {} }} {{flag?1:2}} {{ (function() {return
  100})() }}
</div>
<script>
  const vm = new Vue({
    el: "#app",
    data: {
      msg: "hello",
      info: {},
      flag: true,
    },
    methods: {},
  });
</script>
```

- 打印立即执行函数的返回值也是允许的
- 上面的代码中，info.a 不存在，但是不会报错，只是不显示
- 如果在浏览器控制台中输入 vm.info.a = 100，页面上也不会显示 info.a
- 只要使用 vue 中的数据，就要先声明，再使用

```js
// 对上面的代码进行修改，如下所示
const vm = new Vue({
  el: "#app",
  data: {
    msg: "hello",
    info: {},
    flag: true,
  },
  methods: {},
});

vm.msg = "nihao";
console.log(vm.$el.innerHTML);
```

- 先修改 vm.msg 的值，再打印节点中的内容，结果发现 innerHTML 中的 msg 还是 hello，如下图所示
  <image src="./images/01.jpg"></image>
- 因为 dom 的更新是异步的
- 可以使用 vm.$nextTick 获取更新后的结果

```js
vm.msg = "nihao";
vm.$nextTick(function () {
  console.log(vm.$el.innerHTML);
});
```

- vm.$nextTick 会在当前页面更新完 dom 以后再执行它的回调函数
- dom 操作时必备

```js
// 或者可以使用vm.$watch
vm.$watch("msg", function (newValue, oldValue) {
  console.log(newValue, oldValue);
});

vm.msg = "nihao";
vm.msg = "hi";
```

- 虽然对 msg 进行了两次修改，但是$watch 中的回调函数只执行了一次，结果如下：
  <image src="./images/02.jpg"></image>
- 因为 dom 更新是异步的，vue 会将更新整合到一起再去调用回调函数，所以只执行一次

### 常见的几个属性

- vm.$el 指代的就是当前的元素
- vm.$data 当前数据对象
- vm.$nextTick 延迟执行，dom 操作时必备
- vm.$watch 监控数据变化
- vm.$options 所有的选项
- vm.$set
- vm.$mount 挂载  单元测试，在内存中挂载vue实例，此时只能用$mount 属性

```js
// 这个实例里面没有el属性，通过$mount挂载
const vm = new Vue({
  data: {
    msg: "hello",
    info: {},
    flag: true,
  },
  methods: {},
});

vm.$mount("#app");
```
